{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"caddy_ai2/","title":"Caddy AI2","text":"<p>Este es el modelo antiguo del RBCar de Robotnik. Este fue adquirido ya hace unos a\u00f1os por el AI2. El grupo de trabajo CO3 ahora ha heredado este coche. Internamente hemos decidido llamarle Caddy AI2.</p> <p></p> <p>Como ven\u00eda diciendo, este prototipo se hereda de un proyecto anterior: IDECONA AI2, os recomiendo ver el material Multimedia - IDECONA AI2. </p> <p>El coche tiene una compleja y no demasiado documentada informaci\u00f3n sobre como es el cableado, esquemas el\u00e9ctricos, etc... A nivel software funciona actualmente con una versi\u00f3n obsoleta de ROS 1 Indigo Igloo con Ubuntu 14 (sin parche del tiempo de real - PREEMPT RT).</p> <p>La intenci\u00f3n es actualizar el coche adaptando las piezas de hardware y software necesarias para tener un coche con la versi\u00f3n actual de ROS 2 Humble y Ubuntu 22 (es posible que con PREEMPT RT).</p>"},{"location":"caddy_ai2/#partimos-de-la-base-de-software","title":"Partimos de la base de software:","text":"<p>Tenemos los repositorios de c\u00f3digo de Robotnik y otros extra\u00eddos de un backup de c\u00f3digo del workspace del robot:</p> <ul> <li>https://github.com/CO3-UPV/rbcar_sim</li> <li>https://github.com/CO3-UPV/rbcar_common</li> <li>https://github.com/CO3-UPV/robotnik_sensors</li> <li>https://github.com/CO3-UPV/rbcar_robot (rescatado del coche, esta es realmente importante)</li> </ul> <p>De estos paquetes, se han eliminado las ramas de ROS posteriores a indigo-devel, porque corresponden al nuevo modelo de Robotnik, conservando la rama de indigo-devel.</p> <p>Cambios en el chasis:</p> <ul> <li>Se han a\u00f1adido tres pasamuros a la caja para pasar cableado a su interior de forma sencilla: Customizable threaded grommet by makmonty - Thingiverse</li> </ul>"},{"location":"caddy_ai2/bateria/","title":"Bater\u00eda","text":""},{"location":"caddy_ai2/bateria/#mantenimientos","title":"Mantenimientos","text":"<ul> <li>02/04/2024</li> <li>18/07/2024 (Comprobaci\u00f3n (*)) </li> </ul> <p>((*)no fue necesario rellenar la bater\u00eda de agua destilada)</p>"},{"location":"caddy_ai2/bateria/#ultimo-mantenimiento-02042024","title":"\u00daltimo mantenimiento: 02/04/2024","text":""},{"location":"caddy_ai2/bateria/#configuracion","title":"Configuraci\u00f3n","text":""},{"location":"caddy_ai2/bateria/#configuracion-de-las-baterias-en-serie","title":"Configuraci\u00f3n de las bater\u00edas en serie","text":""},{"location":"caddy_ai2/bateria/#anteriormente-tenia-8-baterias","title":"Anteriormente ten\u00eda 8 bater\u00edas:","text":"<ul> <li>Bater\u00edas Trojan T-125 6V 240 Ah</li> </ul>"},{"location":"caddy_ai2/bateria/#actualmente-tiene-8-baterias","title":"Actualmente tiene 8 bater\u00edas:","text":"<ul> <li>Bater\u00edas Trojan T-105 6V 225 Ah</li> </ul>"},{"location":"caddy_ai2/bateria/#justificacion-de-compra","title":"Justificaci\u00f3n de compra:","text":"<ul> <li>Compatibilidad con la anteriores bater\u00edas</li> <li>Facilidad en la gesti\u00f3n y compra</li> </ul>"},{"location":"caddy_ai2/bateria/#carga","title":"Carga","text":""},{"location":"caddy_ai2/bateria/#frecuencia-de-carga-sin-uso","title":"Frecuencia de carga sin uso:","text":"<p>Cada mes, mes y medio.</p>"},{"location":"caddy_ai2/bateria/#tiempo-de-carga","title":"Tiempo de carga:","text":"<p>De 2 a 4 horas de carga.</p>"},{"location":"caddy_ai2/bateria/#por-bateria","title":"Por bater\u00eda:","text":"<ul> <li>Voltaje m\u00ednimo: 6V</li> <li>Voltaje m\u00e1ximo: 6.3V</li> </ul>"},{"location":"caddy_ai2/bateria/#lote-de-8-baterias","title":"LOTE de 8 bater\u00edas:","text":"<ul> <li>Voltaje m\u00ednimo: 48V</li> <li>Voltaje m\u00e1ximo: 50.4V</li> </ul>"},{"location":"caddy_ai2/bateria/#cargador","title":"Cargador","text":""},{"location":"caddy_ai2/bateria/#conectores","title":"Conectores","text":""},{"location":"caddy_ai2/bateria/#conector-macho-del-cargador","title":"Conector macho del cargador","text":""},{"location":"caddy_ai2/bateria/#conector-hembra-del-cargador","title":"Conector hembra del cargador","text":""},{"location":"caddy_ai2/bateria/#componentes-necesarios","title":"Componentes necesarios","text":"<ul> <li>Agua destilada</li> <li>Jeringuilla</li> <li>Gafas de protecci\u00f3n</li> <li>Guantes no permeables (por ejemplo, nitrilo, como en la imagen inferior)</li> <li>Linterna (para mirar el nivel)</li> </ul>"},{"location":"caddy_ai2/bateria/#frecuencia-de-rellenado-cada-23-meses","title":"Frecuencia de rellenado cada 2/3 meses","text":""},{"location":"caddy_ai2/bateria/#procedimiento","title":"Procedimiento","text":"<p>Ponerse los guantes y gafas. Tener cuidado con una posibles salpicaduras. </p> <p>Que cubra el agua destilada un poco por encima de las placas de la bater\u00eda,  no llenar hasta arriba, con que las placas no est\u00e9n al aire es suficiente, ayudarse de la jeringuilla para el rellanado.</p> <p>Precauci\u00f3n con el fuego porque las bater\u00edas liberan hidrogeno durante le carga. Evitar a toda costa que haya elementos que generen ignici\u00f3n. Sin chispas ni llamas. </p> <p>Video de Youtube con el procedimiento</p>"},{"location":"caddy_ai2/desarrollo/","title":"Desarrollo","text":""},{"location":"caddy_ai2/desarrollo/#instalacion-de-ros-1-indigo-con-ubuntu-14","title":"Instalaci\u00f3n de ROS 1 Indigo con Ubuntu 14","text":"<p>No recomiendo perder el tiempo con la instalaci\u00f3n para desarrollar paquetes para esta versi\u00f3n, recomiendo usar la maquina virtual de (Nootrix built VM), ve\u00e1se https://wiki.ros.org/indigo/Installation en el apartado Unofficial Installation Alternatives - Nootrix built VM -- Nootrix Downloads -- -- Copia de seguridad en MEGA - versi\u00f3n 64 bits</p> <p>Con esta maquina virtual podr\u00e1s desarrollar paquetes c\u00f3modamente para el coche, incluso ejecutar la simulaci\u00f3n.</p>"},{"location":"caddy_ai2/desarrollo/#_1","title":"Desarrollo","text":""},{"location":"caddy_ai2/gamepad/","title":"Gamepad","text":""},{"location":"caddy_ai2/gamepad/#ps3-controller","title":"PS3 Controller","text":"<p>Es un mando de una SONY Playstation 3 empleado para controlar el coche.</p>"},{"location":"caddy_ai2/gamepad/#como-emparejarlo-con-el-robot","title":"\u00bfC\u00f3mo emparejarlo con el robot?","text":""},{"location":"comunicacion/uart/","title":"UART - Universal Asynchronous Receiver / Transmitter","text":"<p>UART (universal asynchronous receiver / transmitter, por sus siglas en ingl\u00e9s) es un protocolo de comunicaci\u00f3n serie as\u00edncrona en el cual el formato de datos y las velocidades de transmisi\u00f3n son configurables. Env\u00eda los bits de datos uno por uno, del menos significativo al m\u00e1s significativo, encuadrados por bits de inicio y de parada para que el canal de comunicaci\u00f3n maneje el tiempo preciso. Los niveles de se\u00f1al el\u00e9ctrica son gestionados por un circuito controlador externo al UART. Los niveles de se\u00f1al comunes incluyen RS-232, RS-485 y TTL en bruto para enlaces de depuraci\u00f3n cortos.</p> <p></p> <p>Curiosidad: Un teletipo - \u200bTTY \u00bfos suena de terminal de Linux? (acr\u00f3nimo de la forma inglesa teletype) es un dispositivo telegr\u00e1fico de transmisi\u00f3n de datos, ya obsoleto, utilizado durante el siglo xx para enviar y recibir mensajes mecanografiados punto a punto a trav\u00e9s de un canal de comunicaci\u00f3n simple, a menudo un par de cables de tel\u00e9grafo.</p> <p>Fue uno de los primeros dispositivos de comunicaci\u00f3n para computadoras, utilizado para conectar teletipos a una consola de operador. Tambi\u00e9n fue un sistema de hardware temprano para la Internet.</p> <p>Un UART suele ser un circuito integrado (CI) individual o parte de uno, utilizado para comunicaciones serie a trav\u00e9s de un puerto serie de computadora o dispositivo perif\u00e9rico. Uno o m\u00e1s perif\u00e9ricos UART se integran com\u00fanmente en chips de microcontroladores. UARTs especializados se utilizan en autom\u00f3viles, tarjetas inteligentes y tarjetas SIM.</p> <p>Un dispositivo relacionado, el Receptor-Transmisor Universal S\u00edncrono y Asincr\u00f3nico (USART - universal synchronous and asynchronous receiver-transmitter, por sus siglas en ingl\u00e9s), tambi\u00e9n admite operaciones s\u00edncronas.</p> <p>En t\u00e9rminos del modelo OSI, el UART se encuentra en el nivel 2, la capa de Enlace de Datos.</p> <p></p> <p>Para m\u00e1s informaci\u00f3n sobre el protocolo y las caracter\u00edsticas m\u00edrate en el siguiente enlace, tampoco tiene sentido repetir informaci\u00f3n que puedes encontrar por internet mejor explicado y de forma sencilla: https://www.rohde-schwarz.com/es/productos/test-y-medida/essentials-test-equipment/digital-oscilloscopes/que-es-uart_254524.html</p> <p>Enlazando el modelo OSI, hasta el momento, me surge la duda de como comunicarme con otros dispositivos con mensajer\u00eda (paquetes) est\u00e1ndar para un buen funcionamiento c\u00f3modo y sencillo de programar. Esto exige un protocolo de comunicaci\u00f3n entre ambas partes. </p> <p>En la b\u00fasqueda encontre: - XCP - \"Universal Measurement and Calibration Protocol\" es un protocolo de red situado capa de transporte y red y se puede usar con comunicaciones CAN, SPI, USBm Ethernet, pero es un protocolo propietario y hay que pagar para las obtener las especificaciones. - Serial Line Internet Protocol (SLIP) es un est\u00e1ndar de transmisi\u00f3n de datagramas IP para l\u00edneas serie, pero que ha quedado bastante obsoleto. Es muy sencillo, pero poco robusto.  Existen diversas implementaciones de este estilo como https://github.com/lexus2k/tinyslip, https://github.com/bakercp/PacketSerial, Al igual, que la librer\u00eda anterior, utiliza otro tipo de codificaci\u00f3n llamada COBS, pero no establece ning\u00fan tipo de estructura de mensaje, es solo un tipo de codificaci\u00f3n. https://packetio.readthedocs.io/en/latest/ - Otra soluci\u00f3n prodr\u00eda ser adaptar rosserial (https://wiki.ros.org/rosserial) que tiene una estructura de mensaje interesante, f\u00e1cil de uso, y que puede ser conocido por ser una implementaci\u00f3n de comunicaci\u00f3n de MCU como Arduino a un ordenador con ROS 1. - Existe la libreria para Python llamada serial-packets es muy buena estructura, pero no tiene librer\u00eda de Arduino para comunicarse con esta buena librer\u00eda. https://pypi.org/project/serial-packets/ - Encontre TinyProto de lexus2k basado en RFC 1662. (https://github.com/lexus2k/tinyproto) y la probe esta librer\u00eda me ha resultado interesante pero esta inacabada y por tanto no es funcional.</p> <p>SOLUCI\u00d3N: Encontr\u00e9 esta librer\u00eda para python y arduino, fracamente tiene muy buena pinta. - https://github.com/PowerBroker2/pySerialTransfer - https://github.com/PowerBroker2/SerialTransfer</p> <p>Enlaces: - https://www.rohde-schwarz.com/es/productos/test-y-medida/essentials-test-equipment/digital-oscilloscopes/que-es-uart_254524.html - https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter - https://es.wikipedia.org/wiki/Teletipo - https://en.wikipedia.org/wiki/Universal_synchronous_and_asynchronous_receiver-transmitter - https://en.wikipedia.org/wiki/XCP_(protocol) - https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol - https://wiki.ros.org/rosserial - https://github.com/lexus2k/tinyslip - https://github.com/lexus2k/tinyproto - https://github.com/bakercp/PacketSerial - https://packetio.readthedocs.io/en/latest/</p>"},{"location":"comunicacion/uart2/","title":"Uart2","text":"<p>https://users.ece.utexas.edu/~valvano/mspm0/ebook/Ch8_SerialCommunication.htm</p>"},{"location":"material_educativo/","title":"Index","text":""},{"location":"material_educativo/#youtube","title":"Youtube","text":""},{"location":"material_educativo/#cursos","title":"Cursos","text":"<ul> <li>Optimal Control and Reinforcement Learning (CMU 16-745) Spring 2024 by Prof. Zac Manchester.  Youtube, Youtube - Recitations by Kevin Tracy y Website. </li> </ul> <p>Curso con una lista de 16 videos de 1 hora y algo relacionando el control \u00f3ptimo y la rob\u00f3tica en Ingl\u00e9s. junto a sus recitations, que ayudan a entender la teor\u00eda con la pr\u00e1tica matem\u00e1tica. Tambi\u00e9n disponen de c\u00f3digo de ejemplo en github.</p> <ul> <li>Mobile Wheeled Robots by Santhakumar Mohan (NPTEL-NOC IITM) Youtube</li> </ul> <p>Curso con muchos videos muy \u00fatil para el modelado y otros aspectos de robots m\u00f3viles con ruedas.</p> <ul> <li>Sistemas din\u00e1micos II (introducci\u00f3n a Lyapunov y conceptos asociados necesarios) por Manual Mera. Youtube</li> </ul>"},{"location":"material_educativo/#seminarios","title":"Seminarios","text":"<ul> <li>Stanford Seminar - Model Predictive Control of Hybrid Dynamical Systems Youtube</li> </ul> <p>Este seminario me ha resultado interesante porque permite abordar los sistemas basado en eventos desde el punto de vista de los sistemas h\u00edbridos podr\u00eda ser m\u00e1s c\u00f3modo una vez se ha entendido como trabajar con ellos, tanto desde el punto de vista de Lyapunov como el tiempo discreto y continuo.</p>"},{"location":"programacion/","title":"Editor - Visual Studio Code","text":"<p>Visual Studio Code (VS Code) es un editor de c\u00f3digo fuente desarrollado por Microsoft. Es una herramienta gratuita y de c\u00f3digo abierto que se utiliza principalmente para la programaci\u00f3n y el desarrollo de software. VS Code es altamente personalizable y extensible a trav\u00e9s de una amplia gama de extensiones y complementos disponibles en su marketplace.</p> <p>Entre las caracter\u00edsticas principales de Visual Studio Code se incluyen:</p> <p>Editor de texto avanzado: Proporciona funciones como resaltado de sintaxis, autocompletado inteligente, refactorizaci\u00f3n de c\u00f3digo, b\u00fasqueda y reemplazo avanzados, entre otros.</p> <p>Integraci\u00f3n con Git: Ofrece integraci\u00f3n con el sistema de control de versiones Git, lo que permite a los desarrolladores gestionar sus repositorios directamente desde el editor.</p> <p>Depuraci\u00f3n: Permite depurar c\u00f3digo directamente desde el editor, con soporte para m\u00faltiples lenguajes de programaci\u00f3n y diferentes entornos de ejecuci\u00f3n.</p> <p>Soporte para m\u00faltiples lenguajes de programaci\u00f3n: Viene con soporte integrado para una amplia gama de lenguajes de programaci\u00f3n, y se puede ampliar a\u00fan m\u00e1s mediante extensiones.</p> <p>Terminal integrada: Incluye una terminal integrada que permite a los desarrolladores ejecutar comandos directamente desde el editor, sin necesidad de cambiar de ventana.</p> <p>Temas y personalizaci\u00f3n: Ofrece una variedad de temas predefinidos y opciones de personalizaci\u00f3n para adaptar el entorno de desarrollo a las preferencias individuales de cada desarrollador.</p> <p>Visual Studio Code se ha convertido en una de las herramientas de desarrollo m\u00e1s populares debido a su velocidad, versatilidad y la gran comunidad de desarrolladores que contribuyen con extensiones y mejoras constantemente.</p>"},{"location":"programacion/#recomendaciones-creacion-de-perfiles","title":"Recomendaciones - Creaci\u00f3n de perfiles","text":"<p>Visual Studio Code tiene cientos de configuraciones, miles de extensiones e innumerables formas de ajustar el dise\u00f1o de la interfaz de usuario para personalizar el editor. Los perfiles de VS Code le permiten crear conjuntos de personalizaciones y cambiar r\u00e1pidamente entre ellas o compartirlas con otros. Este tema explica c\u00f3mo crear, modificar, exportar e importar perfiles. https://code.visualstudio.com/docs/editor/profiles</p>"},{"location":"programacion/#extensiones-recomendads","title":"Extensiones recomendads","text":"<ul> <li>Code Spell Checker - Un corrector ortogr\u00e1fico b\u00e1sico que funciona bien con c\u00f3digo y documentos.</li> <li>Markdown All in One - </li> </ul>"},{"location":"prototipos/","title":"Index","text":"<p>LEGO</p> <p></p> <p>Esta entrada describe el proceso de instalaci\u00f3n de ROS 1 Noetic en un LEGO EV3 utilizando Debian Buster de EV3Dev. Primero, se proporciona una imagen preconfigurada para la tarjeta SD del EV3. Para programar se ofrecen recursos audivisuales externos para C++ y Python. El autor detalla el desaf\u00edo de construir la imagen debido a la obsolescencia del equipo y la falta de informaci\u00f3n, eligiendo Debian Buster por su compatibilidad con ROS 1 Noetic. Se utiliza la herramienta Brickstrap para crear im\u00e1genes bootables, con el paso a paso para configurar el entorno, compilando desde cero y lidiando con dependencias. Finalmente, se ofrece una receta Docker para simplificar la instalaci\u00f3n y se proporciona un enlace para descargar la imagen Docker resultante.</p> <p>QUANSER</p> <p></p> <p>La entrada explica c\u00f3mo adaptar el cableado de las maquetas de Quanser, como el 3 DOF Hover y el p\u00e9ndulo giratorio invertido, para su uso con microcontroladores (Arduino, STM32, ESP32) y SBCs (Raspberry Pi, LattePanda Alpha, BeagleBone). Ambos modelos utilizan encoders de cuadratura HEDS-9X00 y motores de corriente continua. Se describe el proceso de construcci\u00f3n de cables compatibles con los encoders, detallando esquemas para distintas configuraciones de voltaje y la adaptaci\u00f3n de los motores, enfatizando la importancia de seleccionar drivers adecuados y fuentes de alimentaci\u00f3n eficientes. El blog destaca la reutilizaci\u00f3n de componentes Quanser con tecnolog\u00edas modernas, promoviendo la educaci\u00f3n e investigaci\u00f3n en mecatr\u00f3nica y control de sistemas. Adem\u00e1s, se proporcionan recursos adicionales y enlaces de referencia para una comprensi\u00f3n m\u00e1s profunda de los temas tratados.</p>"},{"location":"prototipos/lego/","title":"LEGO EV3 con ROS 1 Noetic para Debian Buster de EV3Dev","text":""},{"location":"prototipos/lego/#proceso-de-uso-de-la-imagen","title":"Proceso de uso de la imagen","text":"<p>NOTA: La primera vez que iniciemos el brick, nos pedir\u00e1 que presionemos el bot\u00f3n del centro para continuar, puede ser se reinicie solo o tengamos que quitarle la bater\u00eda.</p> <p>Aqu\u00ed puedes descargar la imagen ya preparada para quemar en la SD:  - https://mega.nz/file/VW8FFTYB#5yEJ2ZTeHwKv5_rbyt10Wcyl_gSJvv8q2AhG3_GTggQ</p> <p>Luego, para poder utilizar ROS debemos cambiar el ROS_MASTER_URI por la direcci\u00f3n apropiada donde se este ejecutando el ROS Core.</p> <p>Para programar en C++ o Python tenemos la siguiente documentaci\u00f3n: https://ev3dev-lang.readthedocs.io/en/latest/</p> <p>Establecer el setup de Visual Studio Code: Youtube - Setting up VS Code EV3 Python programming by Nigel Ward</p>"},{"location":"prototipos/lego/#proceso-de-construccion-de-la-imagen","title":"Proceso de construcci\u00f3n de la imagen","text":"<p>El proceso ha tenido una dificultad media alta debido a la obsolescencia del equipo y a la falta de informaci\u00f3n, pero la justa y necesaria para componer el puzzle. </p> <p>El objetivo para resolver el puzzle es instalar ROS 1 en el LEGO EV3. Haciendo una primera busqueda por internet, encontramos: https://wiki.ros.org/Robots/EV3, y encontramos dos opciones: There is a Debian linux variant: ev3dev and a Yocto Linux variant under development.; una imagen con Debian realizada por EV3Dev y otra imagen de Yocto Linux. </p> <p>Al haber trabajado previamente con LEGO, la imagen de EV3Dev, ya me es conocida, y consiste en grabar una imagen (un fichero) en una SD, y la ponemos en el robot carga el sistema y ya podemos desarrollar aplicaciones en Python, MicroPython y C++. EV3Dev - Documentation - Programming Languages </p> <p>Adem\u00e1s, la p\u00e1gina de ROS nos comenta que existe una herramienta para crear las im\u00e1genes: Brickstrap is a tool for creating bootable image files for embedded systems using Debian Linux.; llamada Brickstrap, esta en su \u00faltima versi\u00f3n genera la imagen a partir de una imagen de Docker, la \u00fanica pega es que solo funciona en Linux. </p> <p>\u00bfY porque no hago una maquina virtual en mi Windows e instalo alg\u00fan Linux y luego Docker? Esto no es posible de momento por el tipo de virtualizaci\u00f3n de Windows. As\u00ed pues, para generar la imagen necesitamos tener acceso a una maquina con Linux, o instalarlo en nuestro PC, si nuestra intenci\u00f3n es generar una nueva imagen. En cambio, si solo queremos compilar un ejemplo (c\u00f3digo) en nuestro Windows con Docker Desktop, y enviarlo a nuestro brick de LEGO, no habr\u00e1 problema, de hecho es lo sugerido por EV3Dev. Using Docker to Cross-Compile</p> <p>Por otra parte, tenemos que la versi\u00f3n Debian 9 Strecth, es la \u00faltima versi\u00f3n compilada en su p\u00e1gina web por el grupo EV3Dev, esta versi\u00f3n de Debian no tiene compatibilidad directa con ROS, aunque da igual, porque hay que realizar la compilaci\u00f3n desde cero. Aunque por otra parte, en su repositorio, tenemos la versi\u00f3n Debian 10 Buster y Debian 11 Bullseye: https://github.com/ev3dev/docker-library, nos decantamos por Debian 10 Buster, porque es la versi\u00f3n compatible con ROS 1 Noetic, y aunque tengamos que compilarlo, habr\u00e1 cierta coherencia con otras instalaciones y versiones de paquetes. Adem\u00e1s, en un PC de sobremesa tambi\u00e9n instalaremos Debian 10 Buster, y as\u00ed tenemos el mismo OS tanto en el LEGO como en el PC.</p> <p></p> <p>Asumiendo que ya tienes una instalaci\u00f3n de Linux, por ejemplo Debian 10 Buster para AMD64 con docker instalado, para poder usar en un futuro Brickstrap, el procedimiento por encima ser\u00eda, empezar por aqu\u00ed github - ev3dev - docker library hasta llegar aqu\u00ed, a este paso docker run --rm -it ev3 su -l robot, aqu\u00ed evitamos este comando docker run --rm -it ev3 para poder ejecutar comando como usuario root. Hacemos los comandos para realizar la instalaci\u00f3n siguiendo algunos de los pasos github - moriarty - brickstrap-build y ROS 1 Noetic - Installing from source adapt\u00e1ndolo a la versi\u00f3n de ROS 1 Noetic, si quieres m\u00e1s info, mirar el TODO: ENLACE, pero lo que hacemos es ir anotando los comandos, puede ser que tengas que volver a empezar varias veces. Una vez, hayamos terminado con el Docker, no lo cierres, desde otra terminal hacemos un commit y hacemos el proceso para pasarlo a una SD, si funciona y nos gusta, podemos quedarnos en este paso haciendo un commit, busca en Internet. Aunque podemos hacerlo m\u00e1s elegante, pas\u00e1ndo los comandos a un fichero Dockerfile y subiendolo a un repositorio como DockerHub para que la comunidad se beneficie de nuestro proyecto.</p> <p>En resumen, hemos generado una receta de Docker a partir de la imagen de ev3dev/ev3dev-buster-ev3-generic y siguiendo los pasos de instalaci\u00f3n, hemos instalado ROS1 1 Noetic desde el source code y empaquetado en una nueva imagen resolviendo las problem\u00e1ticas que aparecen con las depedencias. </p> <p>Para descargar la imagen de Docker, aqu\u00ed la tienes: https://hub.docker.com/repository/docker/racarla96/lego-ev3dev-debian-buster-ros-noetic/general</p>"},{"location":"prototipos/lego/#enlace-de-referencia","title":"Enlace de referencia","text":"<ul> <li>https://github.com/moriarty/ros-ev3 -&gt; https://github.com/moriarty/ros-ev3/blob/master/brickstrap-build-status.md</li> <li>https://gcore.com/learning/how-to-transfer-move-a-docker-image-to-another-system/</li> <li>https://github.com/ev3dev/docker-library</li> <li>https://github.com/ev3dev/brickstrap</li> <li>https://www.ev3dev.org/</li> <li>https://wiki.ros.org/noetic/Installation</li> <li>https://wiki.ros.org/Robots/EV3</li> </ul>"},{"location":"prototipos/mecanum/","title":"Mecanum","text":""},{"location":"prototipos/mecanum/#esquematico-arduino","title":"Esquem\u00e1tico Arduino","text":""},{"location":"prototipos/mecanum/#codigo-de-simulink-para-arduino","title":"C\u00f3digo de Simulink para Arduino","text":"<p>https://github.com/racarla96/Simulink_Arduino_Mecanum_Robot_with_rosserial_ROS_1_Noetic</p>"},{"location":"prototipos/quanser/","title":"Quanser","text":"Adaptaci\u00f3n del cableado para el uso de las maquetas de Quanser con microcontroladores como Arduino, STM32, ESP32 o incluso SBCs como Raspberry Pi, LattePanda Alpha, BeagleBone, etc..."},{"location":"prototipos/quanser/adaptacion/","title":"Adaptaci\u00f3n del cableado para el uso de las maquetas de Quanser con microcontroladores como Arduino, STM32, ESP32 o incluso SBCs como Raspberry Pi, LattePanda Alpha, BeagleBone, etc...","text":"<p>El experimento 3 DOF Hover proporciona un banco de pruebas econ\u00f3mico para comprender y desarrollar leyes de control para la din\u00e1mica de vuelo y el control de veh\u00edculos con despegue vertical. [1]</p> <p>El m\u00f3dulo de p\u00e9ndulo giratorio invertido se conecta a la unidad base del servo giratorio, ampliando los temas de mecatr\u00f3nica y controles que se pueden ense\u00f1ar. El m\u00f3dulo de p\u00e9ndulo desaf\u00eda a los estudiantes no solo a modelar y controlar un p\u00e9ndulo, sino tambi\u00e9n a aprender sobre sistemas de control h\u00edbridos ajustando un sistema de control oscilante. Adem\u00e1s de ense\u00f1ar conceptos de control intermedio, el p\u00e9ndulo rotatorio invertido se puede utilizar para la investigaci\u00f3n en diversas \u00e1reas, incluido el control difuso. [2]</p> <p></p> <p></p> <p>Ambas maquetas est\u00e1n compuestas por encoders de cuadratura y motores de corriente continua, estos nos permiten obtener la posici\u00f3n y actuar sobre la maqueta.</p>"},{"location":"prototipos/quanser/adaptacion/#adaptar-los-encoders","title":"Adaptar los encoders","text":"<p>Para poder leer el encoder, una opci\u00f3n, es acoplarnos al conector que utilizaba Quanser, un conector DIN 5 pines:</p> <p></p> <p>Por tanto, nuestro objetivo es contruir un cable compatible con el encoder que podamos leer con Arduino.</p> <p>Es por ello que primero miraremos que clase de encoders monta. Los encoders que utilizan las maquetas son los HEDS-9X00 que requieren seguir el siguiente esquema:</p> <p></p> <p>Este esquema es \u00fatil cuando el Arduino puede leer se\u00f1ales a 5V. Como vemos utilizaremos unas resistencias entorno a las 3 K\u03a9. Pero si tenemos un Arduino que funciona a 3.3 V tenemos que realizar una peque\u00f1a modificaci\u00f3n, y es poner la resistencia de pull-up a 3.3 V:</p> <p></p> <p>Para montar este esquema con los cables originales de quanser tenemos que tener precauci\u00f3n porque el color del cable (primera imagen) no coincide con los colores que se ven del siguiente conector (el resto de im\u00e1genes) (en estos conectores el canal index no est\u00e1 conectado):</p> <p> </p> <p>Este cable sigue el siguiente patr\u00f3n, para el cable que he construido, he seguido m\u00e1s o menos el mismo patr\u00f3n de color que el conector externo, de ah\u00ed el color entre par\u00e9ntesis:</p> <p> </p> <p>Si por otra parte compramos los conectores de internet y queremos construir nuestro propio cable tenemos el siguiente esquema, a\u00f1adiendo la parte del esquem\u00e1tico con las resistencias de pull-up:</p> <p></p>"},{"location":"prototipos/quanser/adaptacion/#adaptar-los-motores","title":"Adaptar los motores","text":"<p>Para la adaptaci\u00f3n de los motores el proceso es mucho m\u00e1s \"sencillo\", ya que s\u00f3lo debemos tener acceso a la informaci\u00f3n del datasheet del motor y un multimetro, con la intenci\u00f3n de saber la intensidad consumida por el motor.</p> <p>Por ejemplo, con un fuente de alimentaci\u00f3n regulable, que suelen contar un display para visualizar la intensidad consumida, conectamos motor directamente y anotamos la intensidad, personalmente con el voltaje a 12 Voltios cualquier de estos dos prototipos funciona.</p> <p>Para el prototipo del 3 DOF Hover se necesita entorno a 3 Amperios por motor, 12 A en total, mientras que para el prototipo del p\u00e9ndulo con 1 A es suficiente en nominal, aunque si bien es cierto que cuando hay cambios con una din\u00e1mica bastante agresiva, se necesita una fuente con algo de margen.</p> <p>Mi recomendaci\u00f3n es usar una fuente de PC que nos proporciona estos 12 V, y una amperaje muy decente para este prop\u00f3sito, cualquier fuente de un PC de sobremesa actual o algo antiguo puede tener o superar los 180 Watts, m\u00e1s de los 12 A necesarios para los prototipos.</p> <p>Una vez tenemos elegida la fuente, pasamos a los drivers, debemos elegir un driver capaz de soportar esta intensidad, la suerte que tenemos hoy en dia es que por poco dinero podemos tener un driver que supla estas caracter\u00edsticas, yo compr\u00e9 estos drivers por Aliexpress que para este prop\u00f3sito cumplen su papel.</p> <p></p> <p>Por ejemplo, este driver tiene salida para dos motores de corriente continua con una intensidad de 8 A nominal por canal de motor, y es bastante sencillo de usar, su uso depende de cada driver.</p> <p></p> <p>En este caso, viendo la tabla l\u00f3gica nos podemos hacer una idea del funcionamiento del driver. </p> <p></p> <p>Para probar este driver o cualquier otro s\u00f3lo nos queda saber la guinda del pastel y es saber el diagrama del conector con el prototipo. Siguiendo la l\u00f3gica de la opci\u00f3n elegida con el encoder, es  acoplarnos al conector que utilizaba Quanser para los motores, un conector DIN 4 pines:</p> <p></p> <p>Debemos seguir el esquem\u00e1tico sencillo de la imagen de abajo, y ya tendremos nuestro cable listo. El orden de los polos NO da igual, depende del prototipo, si un prototipo, el motor s\u00f3lo gira en un sentido, es posible que el otro polo del motor este conectado a GND como El prototipo de Quanser de 3 DOF Hover. En cambio para el prototipo de p\u00e9ndulo giratorio invertido nos da igual que polo conectar porque el motor necesitamos que gire en ambos sentidos, y el driver del motor DC nos permita aplicar dos PWMs, siempre excluyendo uno PWM del otro al aplicarse, es decir, dejar uno a 0 o en su defecto, hay drivers que esto ya lo contemplan y pueden tener un pin DIR para se\u00f1alar la direcci\u00f3n de giro con un pin digital.</p> <p></p> <p>Peligro - MUY IMPORTANTE</p> <p>El prototipo de Quanser de 3 DOF Hover tiene la toma de tierra compartida (GND), y como los motores s\u00f3lo giran en un sentido hay que tener cuidado de como se conecta el motor y el driver que se le proporciona la polaridad adecuada para su correcto funcionamiento, sino este provocar\u00e1 un cortocircuito. Se debe buscar el positivo del conector DIN con el positivo del motor con el positivo la salida cuando se aplica el PWM al driver, con un multimetro es un momento. El otro polo del motor debe estar conectado a GND de la alimentaci\u00f3n.</p>"},{"location":"prototipos/quanser/adaptacion/#apuntes-para-el-proceso-de-quanser-de-3-dof-hover","title":"Apuntes para el proceso de Quanser de 3 DOF Hover","text":"<p>Para el prototipo de Quanser de 3 DOF Hover, como bien dice la nota, tiene la toma de tierra compartida.</p> <p></p> <p>As\u00ed pues, hay que tener cuidado con el cableado del motor, en este caso yo he optado por seguir este esquema para el conector, dejo los colores rojo y negro, aunque en mi cable sean de color marr\u00f3n y blanco.</p> <p>Como podemos ver en las siguientes im\u00e1genes, tenemos el driver, tanto los transistores como el esquema que representan, en este caso con un \"\u00fanico\" driver de DC para controlar dos motores, el cu\u00e1l presenta 2 puentes en H completos, es decir, 4 medio puentes en H, podemos usar estos 4 medio puentes para controlar los cuatro motores del aparato, ya que solo necesitamos que funcione en un sentido de giro.</p> <p>Por \u00faltimo, comentar esta imagen, aqu\u00ed podemos ver todos los motores conectados con el cableado blanco mientras los marrones est\u00e1n conectados a la toma de tierra.</p> <p></p> <p>Advertencia - EXPERIENCIA</p> <p>No he acabado de tener buena experiencia con estos drivers porque el disipador no ajusta del todo bien, cuando les das ca\u00f1a a los motores, los transistores sufren, se calienten, incluso se han llegado a quemar algunos, no acabo de recomendarlos, asegurar el pad t\u00e9rmico para evitar sobrecalentamientos, incluso cambiar el que viene por defecto.</p>"},{"location":"prototipos/quanser/adaptacion/#conclusion","title":"Conclusi\u00f3n","text":"<p>La adaptaci\u00f3n de las maquetas de Quanser para microcontroladores como Arduino, STM32, ESP32, o sistemas basados en Linux como Raspberry Pi, LattePanda Alpha, BeagleBone, entre otros, abre nuevas oportunidades en educaci\u00f3n e investigaci\u00f3n en mecatr\u00f3nica y control de sistemas. Este proceso implica ajustar los encoders HEDS-9X00 y los motores de corriente continua para su compatibilidad con microcontroladores y fuentes de alimentaci\u00f3n comunes. Esta adaptaci\u00f3n simplificada, junto con la disponibilidad de componentes est\u00e1ndar y recursos detallados, ofrece una plataforma vers\u00e1til y accesible para experimentaci\u00f3n y aprendizaje, promoviendo el desarrollo de habilidades en control y dise\u00f1o de sistemas din\u00e1micos.</p>"},{"location":"prototipos/quanser/adaptacion/#mas-sobre-encoder-de-cuadratura","title":"M\u00e1s sobre encoder de cuadratura","text":"<ul> <li>https://makeatronics.blogspot.com/2013/02/efficiently-reading-quadrature-with.html</li> <li>https://electronics.stackexchange.com/questions/360637/quadrature-encoder-most-efficient-software-implementation</li> </ul>"},{"location":"prototipos/quanser/adaptacion/#enlaces-de-referencia","title":"Enlaces de referencia","text":"<ul> <li>[1] https://www.quanser.com/products/3-dof-hover/</li> <li>[2] https://www.quanser.com/products/rotary-inverted-pendulum/</li> </ul>"},{"location":"ros2/tutoriales-externos/","title":"Tutoriales externos","text":"<ul> <li>Medium - Installing ROS 1 Noetic on Ubuntu 22.04 by Jean-Guillaume Durand</li> </ul> <p>Videos:</p>"},{"location":"sensores/","title":"Index","text":""},{"location":"sensores/#sample","title":"Sample","text":"<p>One more, finally. Or not? :)</p> <p>Now:</p> <pre><code>$ some \n</code></pre> <p>Look what she said:</p> <p>This is it!</p>"},{"location":"sensores/#subtitle","title":"Subtitle","text":"<p>And now this:</p> <ul> <li>One</li> <li>Two</li> <li>Three</li> </ul>"},{"location":"sensores/#as-well","title":"As well","text":""},{"location":"sensores/#as-this","title":"As this","text":""},{"location":"sensores/#another","title":"Another","text":"<p>a link</p> <p>More?</p> <p>Can we now have <code>the build</code>?</p> <p>NOW!</p> <p>Not gonna work, is it?</p>"},{"location":"sensores/pos_int/mavermind/","title":"Marvelmind Robotics","text":""},{"location":"sensores/pos_int/mavermind/#partes","title":"Partes","text":"<ul> <li>1x Modem hw v4.9: (Enlace a la versi\u00f3n actualizada v5.1 - caracter\u00edsticas similares) -&gt; https://marvelmind.com/product/modem-hw-v5-1</li> <li>7x Beacon HW v4.9 (2x con IMU): (Enlace al pack actualizado - caracter\u00edsticas similares) -&gt; https://marvelmind.com/product/starter-set-super-mp-3d/</li> </ul>"},{"location":"sensores/pos_int/mavermind/#configuracion-de-las-balizas","title":"Configuraci\u00f3n de las balizas","text":"<p>Tenemos tres tipos de architecturas (formas de ubicarnos con las balizas):  - Non-Inverse Architecture (NIA)  - Inverse Architecture (IA)  - Multi-Frequency NIA (MF NIA) - Requiere comprar una licencia para su uso.</p>"},{"location":"sensores/pos_int/mavermind/#non-inverse-architecture-nia","title":"Non-Inverse Architecture (NIA)","text":""},{"location":"sensores/pos_int/mavermind/#inverse-architecture-ia","title":"Inverse Architecture (IA)","text":""},{"location":"sensores/pos_int/mavermind/#multi-frequency-nia-mf-nia","title":"Multi-Frequency NIA (MF NIA)","text":""},{"location":"sensores/pos_int/mavermind/#interfaz-hardware","title":"Interfaz hardware","text":"<p>Enlace principal de la marca: https://marvelmind.com/</p>"}]}